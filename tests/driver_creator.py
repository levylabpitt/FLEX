import os
import json
import zmq
import time

_TEMPLATE = '''"""
Auto-generated driver for {class_name} instrument.

This driver communicates with the instrument using ZMQ and provides wrapper functions
for available commands.

Generated by: Auto-Driver Generator
"""

import json
import time
import zmq
import os
import logging

_DEFAULT_ADDRESS = "tcp://localhost:{port}"

# Ensure log path exists
logpath = os.path.join(os.environ.get("LOCALAPPDATA", os.getcwd()), "{class_name}_logs")
os.makedirs(logpath, exist_ok=True)

class {class_name}:
    def __init__(self, address=_DEFAULT_ADDRESS):
        self.address = address
        self.context = zmq.Context()
        self.socket = self.context.socket(zmq.REQ)
        self.socket.connect(self.address)

        # Logging setup
        self.log_file = os.path.join(logpath, "{class_name}.log")
        logging.basicConfig(
            level=logging.INFO,
            format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
            handlers=[
                logging.FileHandler(self.log_file),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)

    def _send_command(self, cmd, params=None):
        try:
            command = {{
                "jsonrpc": "2.0",
                "method": cmd,
                "params": params or {{}},
                "id": str(int(time.time()))
            }}
            self.socket.send_string(json.dumps(command))
            response = self.socket.recv_string()
            return json.loads(response)
        except (zmq.ZMQError, json.JSONDecodeError) as e:
            self.logger.error(f"Error sending command {{cmd}}: {{e}}")
            return {{"error": str(e)}}

{methods}

if __name__ == "__main__":
    instrument = {class_name}()
    print(f"{class_name} driver loaded successfully.")
'''
    

def get_available_commands(port):
    """
    Connects to the instrument and retrieves available commands.

    Returns:
        list: A list of available command names.
    """
    context = zmq.Context()
    socket = context.socket(zmq.REQ)
    socket.connect(f"tcp://localhost:{port}")

    help_command = {
        "jsonrpc": "2.0",
        "method": "HELP",
        "id": "9998"
    }

    try:
        socket.send_string(json.dumps(help_command))
        response = socket.recv_string()
        response_json = json.loads(response)
        return response_json.get("result", [])
    except (zmq.ZMQError, json.JSONDecodeError) as e:
        print(f"Error fetching commands: {e}")
        return []

def generate_method_definitions(commands):
    """
    Generates method definitions based on available instrument commands.

    Args:
        commands (list): List of command names.

    Returns:
        str: A formatted string containing Python method definitions.
    """
    method_definitions = []
    
    for cmd in commands:
        method_name = cmd.lower()
        method_code = f"""
    def {method_name}(self, **kwargs):
        \"\"\"Sends the '{cmd}' command to the instrument.\"\"\"
        return self._send_command("{cmd}", kwargs)"""
        method_definitions.append(method_code)
    
    return "\n".join(method_definitions)


def create_driver_file(port, class_name, file_path):
    """
    Creates or updates a driver file for the specified instrument.

    Args:
        port (int): Port number of the instrument.
        class_name (str): Name of the class.
        file_path (str): Path to save the generated driver file.
    """
    commands = get_available_commands(port)
    
    if not commands:
        print("No commands retrieved. Check instrument connectivity.")
        return

    methods = generate_method_definitions(commands)
    driver_code = _TEMPLATE.format(class_name=class_name, port=port, methods=methods)

    with open(file_path, "w") as f:
        f.write(driver_code)

    print(f"Driver file created at {file_path}")


if __name__ == "__main__":
    port = input("Enter instrument port number: ")
    class_name = input("Enter class name for the instrument: ")
    file_path = input("Enter file path to save the driver (e.g., ./instrument.py): ")

    create_driver_file(port, class_name, file_path)
